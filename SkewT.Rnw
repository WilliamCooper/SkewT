%% LyX 2.3.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\usepackage{babel}
\usepackage[unicode=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Special footnote code from the package 'stblftnt.sty'
%% Author: Robin Fairbairns -- Last revised Dec 13 1996
\let\SF@@footnote\footnote
\def\footnote{\ifx\protect\@typeset@protect
    \expandafter\SF@@footnote
  \else
    \expandafter\SF@gobble@opt
  \fi
}
\expandafter\def\csname SF@gobble@opt \endcsname{\@ifnextchar[%]
  \SF@gobble@twobracket
  \@gobble
}
\edef\SF@gobble@opt{\noexpand\protect
  \expandafter\noexpand\csname SF@gobble@opt \endcsname}
\def\SF@gobble@twobracket[#1]#2{}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\begin{document}
\EOLmemo 

\global\addressee={Ranadu documentation}  % >>change "File" to the "To:" name desired

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & Skew-T diagram\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=

thisFileName <- "SkewT"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require (nleqslv, quietly = TRUE, warn.conflicts=FALSE)
library(knitr)
library(tidyverse)
opts_chunk$set (echo=FALSE, include=FALSE, fig.lp="fig:", size='footnotesize')
opts_chunk$set (fig.width=6, fig.height=6, fig.pos="center", digits=4)
opts_chunk$set (warnings=FALSE, strip.white=TRUE)
EPS <- StandardConstant ("MWW") / StandardConstant ("MWD")
TZERO <- StandardConstant ("Tzero")

@

\section{Introduction and goal}

The skew-T diagram (formally, the Skew-T log-P diagram) and related
thermodynamic diagrams (tephigram, emagram, pastagram, aerogram, St$\ddot{\mathrm{u}}$ve
diagram) are standard tools for analysis of stability in the atmosphere.
There are many versions of this diagram available. A fairly recent
and very well documented source is \href{http://bretwhissel.net/skewt/}{this URL},
provided by Bret Whissel. Blank diagrams and also source code are
available here. The Storm Prediction Center, National Centers for
Environmental Prediction, Norman, OK, uses a sounding analysis system
called NSHARP, but it has been updated frequently since its introduction
and I haven't yet learned the details of how it currently is generated.
NCL (see \href{https://www.ncl.ucar.edu/Applications/skewt.shtml}{this link})
provides a skew-T diagram based on the USAF diagram (form dod-wpc
9-16-1) but this dates back to the 1970s and so probably uses the
Rossby form for equivalent potential temperature. Another source of
standard USAF DOD diagrams is \href{http://www.weathergraphics.com/reference/}{Weather Graphics}.

There have been two recent developments that have potential influences
on the pseudo-adiabats in the skew-T diagram. First, Davies-Jones
(Davies-Jones, R., 2009: On formulas for equivalent potential temperature.
Mon. Wea. Review, 137, 3137-- 3148) developed an improved representation
for the pseudoadiabatic equivalent potential temperature, taking into
account factors like the variation of the latent heat of vaporization
with temperature and making other adjustments. Second, Murphy and
Koop (Q.~J.~R.~Meteorol.~Soc.~(2005), 131, pp. 1539--1565) developed
an improved representation of the equilibrium water vapor pressure
as a function of temperature. So far as I have been able to find,
these advances have not been incorporated into thermodynamic diagrams
that are readily available. Furthermore, any definition of pseudo-adiabatic
equivalent potential temperature will likely involve approximations
because the specific heat and latent heat of vaporization of water
vary with temperature, and the former has not been included even in
the Davies-Jones formula. For that reason, the goal here is to construct
new diagrams based on those two advances. For the pseudo-adiabatics,
the calculation will be based on direct integration of the differential
equation representing constant entropy, as discussed in a 2011 memo
referenced from the document ProcessingAlgorithms.pdf.

\section{The basic equations and general approach}

\subsection{The coordinate transformation}

The basic coordinates in a skew-T log-p diagram are an ordinate that
is based on the base-10 logarithm of the pressure and isotherms that
are geometrically at 45$^{\circ}$ slope with respect to both the
abscissa and ordinate. This leads to an abscissa coordinate that is
a function of both temperature and pressure and is expressed as a
value in the range 0--1 (the plot limits):

\begin{equation}
x=\frac{T-T_{l}}{T_{h}-T_{l}}-\frac{\log_{10}(p/p_{l})}{\log_{10}(p_{l}/p_{h})}\label{eq:x-coordinate}
\end{equation}

where $T$ and $p$ are the respective temperature {[}$^{\circ}$C{]}
and pressure {[}hPa{]} and \{$T_{l},\,T_{h}$\} and \{$p_{l},\,p_{h}$\}
are the respective lower and upper limits for temperature along the
abscissa and ordinate. For generating the diagram, this is coded into
a function that provides the abscissa for the plot, as follows:

<<XYplot-function, echo=TRUE, include=TRUE>>=

####
##  given temperature (deg.C) and pressure (hPa), generates the appropriate abscissa coordinate
##  and returns that along with the original pressure is a vector suitable for plotting.
####
# references tBot, tTop, pBot, pTop in the global environment!! caution!!
XYplot <- function (.T, .p) { 
  return (data_frame (X=(.T-tBot) / (tTop-tBot) - log10(.p/pBot) / log10(pBot/pTop), Y=.p))
}

@

\subsection{The structure for the plot data and background}

A convenient way to represent the values used to construct the plots
is in terms of data.frames, with the following structure:
\begin{enumerate}
\item Each data.frame has pressure as the first variable and specific values,
perhaps 1 or 2 hPa apart, that represent levels for the other variables.
\item Other variables in the data.frame contain the temperature corresponding
to a particular value of the variable at the corresponding pressure
level in the data.frame. For example, in the data.frame containing
mixing ratio, a variable MR10 may appear that contains, at each pressure
level, the temperature at which the equilibrium mixing ratio at that
pressure would be 10.
\item The line can then be plotted on the skew-T diagram using the coordinates
XYplot (DF\$MR10, DF\$P) where DF is the data.frame containing the
results of prior calculation. 
\item The structure for the data.frame is as follows:
\end{enumerate}
\begin{center}
{\small{}}%
\begin{tabular}{|c|c|c|c|c|}
\hline 
\textbf{\small{}variable} & \textbf{\small{}columns} & \textbf{\small{}number of variables} & \textbf{\small{}first value } & \textbf{\small{}last value }\tabularnewline
\hline 
\hline 
{\small{}Pressure} & {\small{}P (length 1100 to 50 by 5)} & {\small{}1} &  & \tabularnewline
\hline 
{\small{}Theta} & {\small{}ThetaM100 to ThetaP200} & {\small{}61 (by 5)} & {\small{}$T_{0}$-100} & {\small{}$T_{0}$+200 }\tabularnewline
\hline 
{\small{}Mixing Ratio} & {\small{}MR0.01 to MR30} & {\small{}15 specified levels} & {\small{}0.01 / 1000} & {\small{}30 / 1000}\tabularnewline
\hline 
{\small{}Rossby ThetaE} & {\small{}ThetaEM60 to ThetaE50} & {\small{}23 (by 5)} & {\small{}-60+$T_{0}$} & {\small{} 50+$T_{0}$}\tabularnewline
\hline 
{\small{}DJ ThetaE} & {\small{}ThetaPM60 to ThetaP50} & {\small{}``} & {\small{}``} & {\small{}``}\tabularnewline
\hline 
{\small{}Direct-integration} & {\small{}ThetaIM60 to ThetaI50} & {\small{}``} & {\small{}``} & {\small{}``}\tabularnewline
\hline 
\end{tabular}{\small\par}
\par\end{center}

The pressure variable determines the number of rows for each of the
other variables, so for example each of multiple columns for Theta
has the same length as the pressure variable. However, there are 300/5+1=61
Theta rows representing individual values of Theta vs pressure, so
for example there is a row of values for Theta=$T_{0}-100$ called
ThetaM100 representing the temperature corresponding to that value
of Theta at each pressure level. Once this table is constructed, plots
can be generated from data in the table without need to repeat the
calculations, and the table can be saved as a reference for generating
sub-plots that might span only parts of the range covered by the table. 

The plot background itself is then constructed from ggplot calls to
make it possible to save the generated background for overplotting
with data.

\subsection{Basic lines: isotherms, isobars, dry adiabats}

Plotting the isobars and isotherms is then straightforward. For dry
adiabats, solving the equation for potential temperature gives the
following equation for the temperature $T$ corresponding to pressure
$p$:

\begin{equation}
T=\left(T_{R}\right)\left(\frac{p}{p_{l}}\right)^{R_{d}/c_{pd}}-T_{0}\label{eq:T-for-pot-T}
\end{equation}
where $T_{R}$ is the reference temperature for the potential-temperature
line (in kelvin) at the lower limit for $p$ (or, conventionally,
1000\,hPa, where $T_{R}$ is also the potential temperature) and
$T_{0}$ is 273.15\,K. In this equation, dry-air values are conventionally
used for the gas constant ($R_{d}$) and the specific heat at constant
pressure ($c_{pd}$), although this can introduce errors of 1\,K
or more for moist air. For this reason, it may be helpful to plot
a range about the dry adiabats to represent this uncertainty, using
as an indication of error the value of $T$ the difference between
the above value and that obtained for 100\% relative humidity, using
the relationship \\
\[
\frac{R}{c_{p}}=\frac{R_{d}}{c_{pd}(1+\frac{1}{5}\frac{e}{p})}
\]

where quantities with subscript $d$ refer to dry air (cf.\href{https://drive.google.com/file/d/0B1kIUH45ca5Ab2Z6cld1M1cydjA/view\%3Fusp\%3Dsharing}{ ProcessingAlgorithms.pdf},
p. 38).

<<basic-lines, eval=FALSE, echo=TRUE, include=TRUE>>=

pBot <- 1100
pRef <- 1000
pTop <- 50
tTop <- 50
tBot <- -50
tMin <- -140
CP <- SpecificHeats ()
RbyCP <- CP[3] / CP[1]
pLevels <- seq (pBot, pTop, by=-5)
tLevels <- seq (tMin, tTop, by=5)
plot (c(0., 1.), c(pTop, pBot), log='y', ylim=c(1000, 100),pch=NA)
for (p in pLevels) {
  lines (c(0., 1.), c(p, p))
}

for (t in tLevels) {
  x1 <- XYplot (t, pBot)[1]
  y1 <- pBot
  x2 <- x1 + 1
  y2 <- pTop
  lines (c(x1, x2), c(y1, y2), col='blue')  
}

## start building data.frame to contain arrays holding lines to be plotted
SkewTData <- data_frame (P=pLevels)
for (theta in seq (TZERO - 100, TZERO + 200, by=5)) {
  lines (XYplot (theta / ((1000/pLevels) ^ RbyCP) - TZERO, pLevels), col='orange')
  SkewTData[sprintf("Theta%.2f", theta)] <- theta / ((1000/pLevels) ^ RbyCP) - TZERO
}

@

\subsection{Mixing ratio}

Lines representing constant mixing ratio on a thermodynamic diagram
represent the equilibrium value at the specified temperature and pressure,
and so are often considered in relationship to measurements of dew
point in sounding plots. Expressed in units of grams per kilogram
of dry air, the mixing ratio $\mathrm{MR}$ for moist air in equilibrium
with a plane water surface at temperature $T$ and pressure $p$ is

\begin{equation}
\mathrm{MR=1000\thinspace\epsilon\frac{e_{s}(T)}{(p-e_{s}(T))}}\label{eq:MR}
\end{equation}

where $e_{s}(T)$ is the equilibrium water vapor pressure. Given a
specified value of $\mathrm{MR}$, the value of $T$ giving that mixing
ratio at a specified pressure can be found numerically by solving
\[
\mathrm{MR-1000\thinspace\epsilon\frac{e_{s}(T)}{(p-e_{s}(T))}=0}
\]

numerically, varying $T$ with $p$ amd $\mathrm{MR}$ fixed. The
R routine 'nleqslv' is used here to find the temperature, which can
be used with (\ref{eq:x-coordinate}) to find the plotted abscissa
coordinate. This is implemented using this function in the call to
'nleqslv':

<<mr-fn, echo=TRUE, include=TRUE>>=

# note: this omits the enhancement factor, as is conventional def. of eq. vapor pressure
TfromRmix <- function (.T, .rMix, .P) {
  return (.rMix - MixingRatio (MurphyKoop (.T) / .P))
}

@

Using this function with calls to 'nleqslv' for a sequence of pressures
gives a sequence of temperatures and hence a sequence of plot points
for constructing the diagram.

<<mixing-ratio-lines, eval=FALSE, echo=TRUE, include=TRUE>>=

rMix <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 1:3, 5, seq (10, 30, by=5)) * 0.001
tt <- pLevels  # overwritten below, just a quick allocation
for (rmix in rMix) {
  for (i in 1:length (pLevels)) {
    tt[i] <- nleqslv (10., TfromRmix, jac=NULL, rmix, pLevels[i])$x
  }
  lines (XYplot (tt, pLevels), col='darkgreen', lty=2)
  SkewTData[sprintf("MR%.02f", rmix*1000)] <- tt
}

@

\subsection{Pseudo-adiabatic equivalent potential temperature\protect\footnote{Sometimes called, incorrectly, pseudo-equivalent potential temperature
(it is pseudo-adiabatic in the sense that all water condensate is
removed as it appears) or equivalent potential temperature (a term
better understood to refer to the true adiabatic process).}}

The representation of pseudo-adiabats can be done in two ways, either
via the formula of Davies-Jones (2009), as presented in ProcessingAlgorithms.pdf,
p.~50, or by direct integration of the differential equation obtained
by setting the total derivative of entropy with pressure to zero.
Previous integrations, discussed in the memo referenced above, demonstrate
good agreement between these two approaches, but the direct integration
is more basic and is the test against which the Davies-Jones formula
was developed so that will be used here.

For integrations that include representations of the temperature dependence
of the specific heats and latent heat as well as the Murphy and Koop
(2006) representation of equilibrium water vapor pressure, the appropriate
differential form of the entropy can be used to find the pseudo-adiabatic
(or adiabatic) derivative of temperature with respect to pressure.
For an adiabatic process where all changes occur in equilibrium, the
molar entropy $s^{\prime}$ is related to temperature $T$ and pressure
$p$ (for a perfect gas) via

\begin{equation}
Tds^{\prime}=c_{p}^{\prime}dT-v^{\prime}dp\label{eq:2ndLaw}
\end{equation}

where primed quantities refer to molar quantities, such that $c_{p}^{\prime}$
and $v^{\prime}$are the molar heat capacity at constant pressure
and the molar volume, respectively. There are three contributions
to the entropy to consider for a moist air parcel: the entropy of
the (i) dry air; (ii) water vapor; and (iii) liquid water. If the
respective mole numbers of these three components are $n_{d}^{\prime}$,
$n_{v}^{\prime}$, and $n_{w}^{\prime}$, then

\begin{equation}
Tds^{\prime}=(n_{d}^{\prime}c_{pd}^{\prime}+n_{v}^{\prime}c_{pv}^{\prime}+n_{w}^{\prime}c_{w}^{\prime})dT-n_{d}^{\prime}v_{d}^{\prime}dp_{d}-n_{v}^{\prime}v_{v}^{\prime}de+L_{v}^{\prime}dn_{v}^{\prime}\label{eq:EntropySum}
\end{equation}
where $p_{d}$ is the pressure of dry air, $e$ is the water vapor
pressure, and $L_{v}^{\prime}$ is the molar latent heat of vaporization
of liquid water. The last term in (\ref{eq:EntropySum}) arises because
there is an entropy change associated with the phase change from liquid
water to water vapor, and this last term is the heat released by that
phase change.\footnote{An additional contribution arises from the entropy increase associated
with mixing of the water vapor and the dry air, but this is insignificant
and will be neglected.} The other terms arise from summing (\ref{eq:2ndLaw}) for the three
individual components.

The mixing ratios $r$ and$r_{w}$ are, respectively, the masses of
water vapor and liquid water per unit mass of dry air:

\begin{eqnarray}
r & = & \frac{n_{v}^{\prime}M_{w}}{n_{d}^{\prime}M_{d}}\nonumber \\
r_{w} & = & \frac{n_{w}^{\prime}M_{w}}{n_{d}^{\prime}M_{d}}\label{eq:MixingRatioDefs}
\end{eqnarray}

where $M_{w}$ is the molecular weight of water (mass of water per
mole) and $M_{d}$ that of dry air. Dividing (\ref{eq:EntropySum})
by $n_{d}^{\prime}M_{d}T$ and setting $ds^{\prime}$ to zero for
an isentropic process leads to

\begin{equation}
(c_{pd}+rc_{pv}+r_{w}c_{w})\frac{dT}{T}-\frac{v_{d}}{T}dp_{d}-r\frac{v_{v}}{T}de+\frac{L_{v}}{T}dr=0\label{eq:DiffForm1}
\end{equation}

where unprimed quantities $c_{pd}$, $c_{pv}$, $c_{w}$, $v_{d}$,
$v_{v}$, and $L_{v}$ are specific quantities (i.e., per unit mass
of dry air for $c_{pd}$ and $v_{d}$ and per unit mass of water for
$c_{pv}$, $c_{w}$, $v_{v}$ and $L_{v}$; e.g., $c_{pd}=c_{pd}^{\prime}/M_{d}$
and $c_{pv}=c_{pv}^{\prime}/M_{w}$). For perfect gases, $v_{d}/T=R_{d}/p_{d}$
and $v_{v}/T=R_{w}/e$ where $R_{d}$ and $R_{w}$ are the gas constants
for dry air and water vapor, respectively. Also, the ideal-gas form
of the Clausius-Clapeyron equation is 

\begin{equation}
\frac{de_{s}}{e_{s}}=\frac{L_{v}dT}{R_{w}T^{2}}\label{eq:Clausius-Clapeyron}
\end{equation}

and Kirchhoff's equation (cf., e.g., Emanuel 1994, Eq.~4,4,3) is

\begin{equation}
dL_{V}=(c_{pv}-c_{w})\,dT\,\,.\label{eq:Kirchhoff}
\end{equation}

With $e=e_{s}(T)$ and $r=r_{s}(T)=\frac{M_{w}}{M_{d}}e_{s}(T)/p_{d}$
as corresponds to a saturated parcel, and with some additional transformations
as follow, all terms in (\ref{eq:DiffForm1}) can be transformed into
differential relationships that only involve derivatives of T and
p:

\[
\frac{L_{v}dr}{T}=\frac{d(L_{v}r)}{T}-r\frac{dL_{v}}{dT}\frac{dT}{T}=\frac{d(L_{v}r)}{T}-r(c_{pv}-c_{w})\frac{dT}{T}
\]

\[
rR_{w}\frac{de_{s}}{e_{s}}=rR_{w}\frac{L_{vdT}}{R_{w}T^{2}}=\frac{L_{v}r}{T}\frac{dT}{T}
\]

\[
\frac{d(L_{v}r)}{T}=d\left(\frac{L_{v}r}{T}\right)+\frac{L_{v}r}{T}\frac{dT}{T}
\]

\[
d\left(\frac{L_{v}r}{T}\right)=\left(\frac{\partial\left(\frac{L_{v}r}{T}\right)}{\partial T}\right)_{p_{d}}dT+\left(\frac{\partial\left(\frac{L_{v}r}{T}\right)}{\partial p_{d}}\right)_{T}dp_{d}=\frac{\epsilon T\,d\left(\frac{L_{v}e_{s}(T)}{T}\right)}{p_{d}dT}\frac{dT}{T}-\frac{L_{v}r}{T}\frac{dp_{d}}{p_{d}}
\]

where the transformation to dependence on $T$ is a consequence of
assuming that the parcel remains saturated, and where the temperature
dependence of $L_{v}$ and the specific heats is implicit. Gathering
terms in (\ref{eq:DiffForm1}) after these transformations leads to

\[
\left[(c_{pd}+r_{t}c_{w})+\frac{T\epsilon}{p_{d}}\left(\frac{\partial\left(\frac{L_{v}e_{s}(T)}{T}\right)}{\partial T}\right)_{p_{d}}\right]\frac{dT}{T}=\left[R_{d}+\frac{L_{v}r}{T}\right]\frac{dp_{d}}{p_{d}}
\]

where $r_{t}=r+r_{w}$ is the total water mixing ratio and where $\epsilon=M_{w}/M_{d}$.
The result then gives a relationship between $T$ and $p_{d}$:

\begin{equation}
\frac{dT}{dp_{d}}=\frac{TR_{d}+L_{v}r}{p_{d}}\,\left[(c_{pd}+r_{t}c_{w})+\frac{T\epsilon}{p_{d}}\left(\frac{\partial\left(\frac{L_{v}e_{s}(T)}{T}\right)}{\partial T}\right)_{p_{d}}\right]^{-1}\label{eq:dTdp}
\end{equation}

The result is a derivative that can be used for numerical integrations
that take into account the temperature dependence of the specific
heats and the latent heat of vaporization and improved representation
of the equilibrium vapor pressure $e_{s}(T)$, as in Murphy and Koop
(2006). This is also used below to evaluate the accuracy of representations
of the equivalent potential temperatures. 

Equation (\ref{eq:dTdp}) is appropriate for the adiabatic process
and so can lead to the wet-equivalent potential temperature $\Theta_{q}$.
The similar formula for the pseudo-adiabatic equivalent potential
temperature $\Theta_{p}$ can be obtained by neglecting the heat capacity
of the liquid water, and so would be the same as (\ref{eq:dTdp})
but with $r_{t}$ replaced by $r$. 

The pseudo-adiabats are then constructed by integration of (\ref{eq:dTdp})
either upward from a fixed starting point at 1000 hPa (which would
represent the wet-bulb pseudo-adiabatic potential temperature) or
starting from a pressure where humidity is negligible (which would
result in pseudo-adiabats labeled by their value equivalent to potential
temperature after all water is condensed). Here the former is chosen.
The integration is performed using the R code that follows.

Another option is to construct the pseudoadiabatc using one of several
alternate forms of the equation for pseudo-adiabatic equivalent potential
temperature. They alternatives (for all of which values are generated
below) are:
\begin{enumerate}
\item The Rossby equation:\\
\begin{equation}
\Theta_{e}^{(Rossby)}=T_{k}\left(\frac{1000}{p-e}\right)^{R_{d}/c_{pd}}e^{L_{v}r/(c_{pd}T_{k}}\label{eq:RossbyEq}
\end{equation}
where $T_{k}$ is the temperature in kelvin, $p$ the total pressure,
$e$ the vapor pressure, $R_{d}$ the dry-air specific heat, $c_{pd}$
the specific heat of dry air, $L_{v}$ the latent heat of vaporization,
and $r$ the water vapor mixing ratio.
\item The Bolton equation:\footnote{David Bolton, 1980: The Computation of Equivalent Potential Temperature.
Mon. Wea. Rev., 108, 1046--1053. doi: http://dx.doi.org/10.1175/1520-0493(1980)108<1046:TCOEPT>2.0.CO;2 }\\
\begin{equation}
\Theta_{e}^{(Bolton)}=T_{k}\left(\frac{1000}{p}\right)^{0.2854(1-0.28\times10^{-3}r)}\exp\left[\left(\frac{3.376}{T_{L}}-0.00254\right)r(1+0.81\times10^{-3}r\right]\label{eq:BoltonEq}
\end{equation}
where $T_{L}$ is the temperature at the lifted condensation level
(which for the purpose of calculating pseudoadiabats can be set to
$T_{k}$; for other purposes, see Eq.~21 of Bolton 1980) and other
symbols are as for the Rossby equation.
\item The Davies-Jones formula:\\
\begin{equation}
\Theta_{p}=T_{k}\left(\frac{1000}{p-e}\right)^{0.2854(T_{k}/T_{L})^{0.28\times10^{-3}r}}\exp\frac{L_{v}^{*}r}{c_{pd}T_{L}}\label{eq:DaviesJonesEq}
\end{equation}
where the latent heat $L_{v}^{*}=2.56313\times10^{6}-1754(T_{L}-T_{0})+1.137\times10^{6}r$
(with $T_{0}=273.15\thinspace$K) is adjusted by fits to integration
results and so differs from the true values of latent heat of vaporization.
For the purpose of determining pseudoadiabats, $T_{L}$ can be set
equal to $T_{k}$.
\end{enumerate}
The procedure used here is to calculate each of these, along with
the direct-integration result, and save the results in a table with
high pressure resolution (5 mb). That table then can be used to construct
a thermodynamic diagram without repeating all the calculations.

<<integration-step, echo=TRUE, include=TRUE>>=

# this chunk includes functions including one to integrate between two levels
# if the specific-heat-of-liquid-water data have not been read, read and store them
if (file.exists ("./SpecificHeatWater.Rdata")) {
  load ("./SpecificHeatWater.Rdata") # reloads cw.table
} else {
  cw.table <- read.table ("./MurphyKoopFig6.txt", sep=',', col.names=c("ID", "T", "cw"))
  cw.table$cw[cw.table$ID == 'n'] <- cw.table$cw[cw.table$ID == 'n'] / StandardConstant("MWW")
  save (cw.table, file="./SpecificHeatWater.Rdata")
}
CWData <- cw.table [ , 2:3]
CWData <- CWData[order(CWData), ]
CWData <- CWData[!is.na(CWData[ ,1]), ]
load ("./CPV.Rdata")
CPV <- as_data_frame(CPV)
  
LatentHeatApprox <- function (.T) {  # input in deg.C
  return (2.501e6 - 2370 * .T)
}
CPWaterVapor <- function (.T) {
  tk <- .T + TZERO
  # note that there was an error in this formula in the earlier ThetaE memo, 3 Jan 2011
  y <- LagrangeInterpolate (tk, 4, CPV)[[1]]
  return(1000 * y)
}
SpecificHeatLiquidWater <- function (.T) {
  tk <- .T + TZERO
  return (1000. * LagrangeInterpolate (tk, 4, CWData)[[1]])
}
# not used; here for reference
LCLfn <- function (.p, RbyCP, thetam, mr) {  # used by LCL function call to nleqslv
  tt <- thetam / (1000/.p)^RbyCP
  ee <- MurphyKoop (tt-TZERO)
  return (ee - mr * .p / (mr + StandardConstant("MWW")/StandardConstant("MWD")))
}

# not used; here for reference; for pseudoadiabat, always at 100% RH
LCL <- function (.RH, .T, .p) {  # .RH in a fraction (not %), .T in deg.C, .p in hPa
  et <- .RH * MurphyKoop (.T)
  mr <- MixingRatio (et/.p)
  CPM <- SpecificHeats (et/.p)
  RbyCP <- CPM[3] / CPM[1]
  thetam <- .T+TZERO * (1000 / .p)^RbyCP
  pLCL <- nleqslv (.p, LCLfn, jac=NULL, RbyCP, thetam, mr)
  tLCL <- thetam / (1000/pLCL)^RbyCP
  return (data_frame ("pLCL"=pLCL, "tLCL"=tLCL))
}

deriv1 <- function (.T, .LV) { # evaluate last partial deriv. in (10)
  delt <- 0.1
  tc <- .T + delt
  LVp <- .LV + (CPWaterVapor (tc) - SpecificHeatLiquidWater (tc)) * delt
  esp <- MurphyKoop (tc)
  delp <- LVp * esp / (.T + delt + TZERO)
  tc <- .T - delt
  LVm <- .LV - (CPWaterVapor (tc) - SpecificHeatLiquidWater (tc)) * delt
  esm <- MurphyKoop (tc)
  delm <- LVm * esm / (.T - delt + TZERO)
  return ((delp-delm) / (2*delt))
}

dTdpdF <- function (.T, .pd, .LV, .rtot=NA, .aflag=FALSE) {
  e <- MurphyKoop (.T)
  p <- .pd + e
  if (.aflag) {  # adiabatic
    rx <- .rtot
  } else {
    rx <- MixingRatio (e/p)
  }
  tk <- .T + TZERO
  cp_x <- CP[1] + rx * SpecificHeatLiquidWater (.T)
  A <- ((tk * SpecificHeats(0)[3] + .LV * MixingRatio (e/p)) / .pd) /
       (cp_x + (EPS * tk / .pd) * deriv1 (.T, .LV))  
  return (A)
}

# integration step: call repeatedly to construct plottable profile
# tk	Initial temperature, kelvin
# p1	Initial pressure, hPa
# p2	 Final pressure, hPa
# value returned, temperature at p2
# aflag  FALSE for pseudoadiabatic, adiabatic otherwise
IntegrationStep <- function (tc, pd1, pd2, rtot, aflag) {
  nsteps <- 5
  delpd <- (pd1 - pd2) / nsteps
  pd <- pd1
  tk <- tc + TZERO
  e <- MurphyKoop (tc)
  p <- pd + e
  r <- MixingRatio (e/p)
  
  # ready to calculate the derivative dT/dp_d, adiabatic and pseudo-adiabatic cases
  while (pd > pd2) {
    if ((pd-delpd) < pd2) {delpd <- pd-pd2}
    dTdpd <- dTdpdF (tc, pd, LV, rtot, aflag) # wet-adiabatic version if aflag TRUE
    tch <- tc - dTdpd * delpd/2
    ex <- MurphyKoop (tch)
    LVh <- LV - (CPWaterVapor (tch) - SpecificHeatLiquidWater (tch)) * dTdpd * delpd / 2
    dTdpd <- dTdpdF (tch, pd-delpd/2, LVh, rtot, aflag)
    tc <- tc - dTdpd * delpd  # take full step with derivative evaluated half-step
    pd <- pd - delpd
    LV <- LV + (CPWaterVapor (tch) - SpecificHeatLiquidWater (tch)) * dTdpd * delpd
  }
  return (tc)
}

@

<<THETA-P, echo=TRUE, include=TRUE, echo=-2, fig.height=6, warning=FALSE>>=

# <<basic-lines>>
# <<mixing-ratio-lines>>

## first show Rossby solution
TWB <- seq (tBot, tTop, by=5)
TfromEPT <- function (.T, .thetaE, .P) {
#  e <- MurphyKoop (.T)
#  r <- MixingRatio (e / .P)
#  lhv <- 2.501e6 - 2370. * .T    # latent heat of vaporization, temp-dependent
#  expn=lhv * r / (CP[1] * (TZERO + .T))
#  return (.thetaE - (TZERO+.T)*(1000/(.P-e))^RbyCP * exp(expn))
  return (.thetaE - RossbyEquivalentPotentialTemperature (.P, .T))
}

# Bolton form
TBfromEPT <- function (.T, .ThetaB, .P) {
  return (.ThetaB - BoltonEquivalentPotentialTemperature (.P, .T))
}

# this is solution of Davies-Jones formula; do integration later
DJTfromEPT <- function (.T, .thetaE, .P) {
  return (.thetaE - EquivalentPotentialTemperature (.P, .T))
}
tt <- pLevels  # shortut to define new vector
for (twb in TWB) {
  thetaR <- RossbyEquivalentPotentialTemperature (1000, twb)
  for (i in 1:length(pLevels)) {
    tt[i] <- nleqslv (10., TfromEPT, jac=NULL, thetaR, pLevels[i])$x
  }
  lines (XYplot (tt, pLevels), col='cyan')
  SkewTData[sprintf("ThetaR%.02f", twb+TZERO)] <- tt
}

for (twb in TWB) {
  thetaB <- BoltonEquivalentPotentialTemperature (1000, twb)
  for (i in 1:length(pLevels)) {
    tt[i] <- nleqslv (10., TBfromEPT, jac=NULL, thetaB, pLevels[i])$x
  }
  lines (XYplot (tt, pLevels), col='green', lwd=2, lty=4)
  SkewTData[sprintf("ThetaB%.02f", twb+TZERO)] <- tt
}


for (twb in TWB) {  # Davies-Jones form
  thetaP <- EquivalentPotentialTemperature (1000, twb, MurphyKoop (twb))
  for (i in 1:length(pLevels)) {
    tt[i] <- nleqslv (10., DJTfromEPT, jac=NULL, thetaP, pLevels[i])$x
  }
  lines (XYplot (tt, pLevels), col='red', lty=2, lwd=1.5)
  SkewTData[sprintf("ThetaP%.02f", twb+TZERO)] <- tt
}


# now add lines obtained by integration:
CP <- SpecificHeats(0)
for (twb in TWB) {
  thetaP <- EquivalentPotentialTemperature (1000, twb)
  ttt <- nleqslv (10., DJTfromEPT, jac=NULL, thetaP, pBot)$x
  # get appropriate starting point in dry-air pressure
  pB <- pBot
  while ((p1 <- pB - MurphyKoop (ttt)) < pLevels[2]) {
    pB <- pB + 10
    ttt <- nleqslv (10., DJTfromEPT, jac=NULL, thetaP, pB)$x
  }
  ptLevels <- pLevels
  ptLevels[1] <- pB
  rtot <- MixingRatio (MurphyKoop (ttt) / pB)
  LV <- LatentHeatApprox (ttt)
  tt[1] <- ttt
  points (XYplot (ttt, pB), pch=16, col='darkorange')
  for (i in 1:(length(pLevels)-1)) {
    tt[i+1] <- IntegrationStep (tt[i], p1, pLevels[i+1], rtot, aflag=FALSE)
    p1 <- pLevels[i+1]
    tch <- (tt[i+1]+tt[i])/2
    LV <- LV + (CPWaterVapor (tch) - SpecificHeatLiquidWater (tch)) * (tt[i+1]-tt[i])
  }
  ptLevels <- pLevels + MurphyKoop(tt)
  ptLevels[1] <- pBot
  ## now interpolate to get tt interpolated to pLevels, for data.frame:
  DI <- data_frame (ptLevels, tt)
  tti <- tt
  for (i in 1:(length(pLevels))) {
    tti[i] <- LagrangeInterpolate (pLevels[i], 4, DI)[[1]]
  }
  lines (XYplot (tti, ptLevels), col='brown', lty=2, lwd=3)
## this needs correction for diff pdry vs p
  SkewTData[sprintf("ThetaI%.02f", twb+TZERO)] <- tti
}

# add a wet-adiabat

TQfromWBPT <- function (.T, .ThetaQ, .P, .rtot) {
  e <- MurphyKoop (.T)
  r <- MixingRatio (e / .P)
 lwc <- ifelse ((.rtot > r), 1000 * (.rtot - r) * (100 * (.P-e) / 
                            (SpecificHeats(0)[3] * (.T+TZERO))), 0.)
  return (.ThetaQ - WetEquivalentPotentialTemperature (.P, .T, 0, lwc))
}

ThetaQ <- WetEquivalentPotentialTemperature (1000, TWB[15])
rTot <- MixingRatio (MurphyKoop (TWB[15]) / 1000)
for (i in 1:length (pLevels)) {
  tt[i] <- nleqslv (10., TQfromWBPT, jac=NULL, ThetaQ, pLevels[i], rTot)$x
}
lines (XYplot (tt, pLevels), col='purple', lty=1, lwd=3)

save(SkewTData, file="SkewTData.Rdata")

@

\section{Constructing the Skew-T background via ggplot}

\subsection{Reasons for using ggplot}

For the plot generated in the preceding sections, the ``base'' graphics
of R have been used. The plot package 'ggplot2' is better suited to
generation of the background for a skew-T plot because it enables
generation via layers and preserving the results in a reusable form.
Layers can represent the isobars, isotherms, pseudo-adiabats, etc,
and for subsequent use as the background for a sounding the result
can be generated by the preserved plot definition, with the actual
sounding over-plotted as an additional layer. That is the approach
taken in the remainder of this document.

\subsection{The basic background}

Here are some variables that determine the range covered by the plot.
These can be changed to give plots covering different areas, although
some work is still needed to get that to work for other than the standard
limits here:

<<adjustable-parameters, echo=TRUE, include=TRUE>>=

####
##   Here are characteristics for the plot, which can be changed as desired.
##   Some other characteristics, like definition of which mixing-ratio lines
##   to plot, have already been determined when the data file was 
##   generated above; see, for example, MR[] there.

##   background color for plot area
bColor <- "gray95"
bColor <- "lightyellow"
bColor <- "lemonchiffon1"
bColor <- "cornsilk"
bColor <- "aliceblue"
bColor <- "ivory"
##   color for pressure lines and plot border, and thickness of lines
pColor <- 'darkblue'        # pressure lines
plwd <- 0.4                 # line width for pressure lines 
## color for isotherms
tColor <- 'darkblue'        # temperature lines
tlwd=0.4                    # line width for temperature lines

pBot <- 1000                # range in pressure and temperature for the plot
pTop <- 100                 # normally 100
tBot <- -40
tTop <- 40
tMin <- -140                # needed to cover isotherms in top-left of plot
## C-130 values:
# pTop <- 300
# tBot <- -20
# tTop <- 40
pLevels <- seq (pBot, pTop, by=-50)    # lines to plot for pressure
tLevels <- seq (tMin, tTop, by=5)      # lines to plot for temperature
####
##   end of changeable plot characteristics
####

@

<<ggplot-call-and-first-layers, echo=TRUE, include=TRUE>>=

require (ggplot2)
require (ggthemes)
require (grid)
library (scales)
## the following is already in memory if this program is run from the beginning, but
## some of the items here including the following "load" of the generated data are
## models for how the generated information can be used. Note that the following datafile
## contains some variables that are not used below but are present because they were
## generated for comparison to the variables actually used.
load ("./SkewTData.Rdata", verbose=TRUE)
## read a file for access to sample data

@

For convenience in determining the correspondence between \{T, P\}
coordinates and plot coordinates, the basic transformation function
used above is redefined here, with the same name as before. The reason
is that there were problems defining a plot with ggplot that had both
logarithmic and reverse-order coordinates, as needed for pressure,
so instead of using that scale definition here a linear scale is used
but values are converted to logarithms before plotting. For that purpose,
the XYplot function is redefined to return the logarithm of the pressure
rather than the pressure as the second coordinate.

<<XYplot, echo=TRUE, include=TRUE>>=

XYplot <- function (.T, .p) {    
  return (data_frame(X=(.T-tBot) / (tTop-tBot) - log10(.p/pBot) / log10(pBot/100),  Y=log10(.p))) 
}

@

Here is code to construct the ggplot definition, with reference to
the data already generated for the isopleths:

<<ggplot-construction, echo=TRUE, include=TRUE, warning=FALSE>>=

NPL <- length (pLevels)
XP <- vector()
YP <- vector()
for (p in pLevels) {  # in general, this is poor, a very slow method in R. But ...
  lp <- log10(p)
  XP <- c(XP, c(0,1,NA))
  YP <- c(YP, lp, lp, 0)
}
XYP <- data_frame (X=XP, Y=YP)
XYP2 <- XYP           # 2nd data.frame to hold line definition skipping even levels,
                      # for plotting solid pressure lines instead of dashed
sq <- 4:5             # assemble a vector of points in XYP2 to skip
j <- 1
while (4+6*j+1 <= length (XYP2$X)) {
  sq <- c(sq, (4+6*j):(4+6*j+1))
  j <- j + 1
}
XYP2$X[sq] <- NA      # this forces the flagged points to be skipped

# Define g to hold the plot definition and the pressure lines
g <- ggplot (data=XYP, aes(x=X, y=Y)) + ylim (log10 (pBot), log10 (pTop))
         # set a background color
g <- g + theme(panel.background = element_rect(fill = bColor))
         # plot the pressure lines, first dashed, then solid
g <- g + geom_path (data=XYP, aes(x=X, y=Y), color=pColor, lty=2, na.rm=TRUE)
g <- g + geom_path (data=XYP2, aes(x=X, y=Y), color=pColor, lty=1, na.rm=TRUE)
         # suppress auto grid lines and axis labels and ticks
g <- g + theme(panel.grid.major = element_blank())
g <- g + theme(panel.grid.minor = element_blank())
g <- g + theme (axis.text = element_blank ())
g <- g + theme (axis.ticks = element_blank ())
         # specify characters for axes
g <- g + theme (axis.title=element_text (face="plain", size=12, colour="blue"))
         # add a border to complete the box around the plot
border <- data_frame (X = c(0,0,NA,1,1), 
            Y = c(log10(pBot), log10 (pTop), log10 (pBot), log10 (pBot), log10 (pTop)))
g <- g + geom_path (data=border, color=pColor, lwd=plwd, na.rm=TRUE)
        # write the axis labels
g <- g + xlab (expression (paste("Temperature or dew point [",degree,"C]")))
g <- g + ylab ("Pressure [hPa]")
         # label the pressure lines, all in one geom_text call with data in DLPLS
pls <- c(seq (pBot, pTop, by=-100), 50)
LPLS <- length(pls)
labl <- character()
for (i in 1:LPLS) {labl <- c(labl, sprintf("%d", pls[i]))}
DLPLS <- data_frame (X=rep(-0.025, LPLS), Y=log10(pls), LABEL=labl)
g <- g + geom_text (data=DLPLS, aes(x=X, y=Y, label=LABEL), size=4)
         # draw the isotherms
xt <- vector ()
yt <- vector ()
for (t in tLevels) {
  XPb <- XYplot (t, pBot)        # (x,y) at bottom axis
  XPt <- XYplot (t, pTop)        # (x,y) at top axis
  if (XPt$X < 0) {next}         # skip lines out of range
  if (XPb$X >= 1) {next}
  if (XPb$X < 0) {               # truncate lines to stay within plot area
    XPb$Y <- XPb$Y+XPb$X
    XPb$X <- 0
  }
  if (XPt$X > 1) {
    XPt$Y <- XPt$Y + XPt$X - 1
    XPt$X <- 1
  }
  xt <- c(xt, c(XPb$X, XPt$X, NA))
  yt <- c(yt, c(XPb$Y, XPt$Y, NA))
}
DT <- data_frame (X = xt, Y = yt)
DT2 <- DT
g <- g + geom_path (data=DT, aes(x=X, y=Y), color=tColor, lwd=tlwd, lty=2, na.rm=TRUE)
sq <- 4:5
j <- 1
while (4+6*j+1 <= length(DT2$X)) {
  sq <- c(sq, (4+6*j):(4+6*j+1))
  j <- j + 1
}
DT2$X[sq] <- NA
g <- g + geom_path (data=DT2, aes(x=X, y=Y), color=tColor, lwd=tlwd, lty=1, na.rm=TRUE)

## add text for temperature, labeling every other line
pltt <- seq (tLevels[3], tLevels[length(tLevels)-2], by=2*(tLevels[2]-tLevels[1]))
LPLT <- length (pltt)
lablt <- character()
for (i in 1:LPLT) {lablt <- c(lablt, sprintf("%d", pltt[i]))}
lablt[lablt=="0"] <- "0  "         # move the 0 to look better
DLPLT <- data_frame (X=XYplot (pltt, pBot)$X, Y=rep(log10(pBot), LPLT), LABEL=lablt)
DLPLT2 <- DLPLT [(DLPLT$X > 0), ]
g <- g + geom_text (data=DLPLT2, aes(x=X, y=Y, label=LABEL, angle=45, hjust=1.4, vjust=0.4), size=4)
g <- g + geom_text (data=DLPLT, aes(x=1.02, y=Y-0.99+X, label=LABEL, angle=45, hjust=-0.3, vjust=-0.0), size=3.5)
## C-130 case:
# g <- g + geom_text (data=DLPLT, aes(x=1.02, y=Y-1+X, label=LABEL, angle=45, hjust=-0.3, vjust=-0.0), size=3.5)
DLPLT3 <- DLPLT[(DLPLT$X < -0.3), ]    ## 50 hPa case
DLPLT3 <- DLPLT[(DLPLT$X < 0 & DLPLT$X > -1), ]       ## 100 hPa case
## C-130 case:
# DLPLT3 <- DLPLT[(DLPLT$X > -0.5 & DLPLT$X < 0.5), ]  # C130 case
# DLPLT3 <- DLPLT3[(DLPLT3$X > -0.5), ]
DLPLT3["Y"] <- rep (log10 (pTop), nrow (DLPLT3))
# g <- g + geom_text (data=DLPLT3, aes(x=X+1.3, y=Y, label=LABEL, angle=35, hjust=-0.2, vjust=0.2), size=2.8)  ## 50 hPa case
g <- g + geom_text (data=DLPLT3, aes(x=X+1.0, y=Y, label=LABEL, angle=35, hjust=-0.2, vjust=0.2), size=2.8)  ## 100 hPa case
# C-130 case:
# g <- g + geom_text (data=DLPLT3, aes(x=X+0.52, y=Y, label=LABEL, angle=35, hjust=-0.2, vjust=0.2), size=2.8)

## add variables from SkewTData:
         # first set pressure out-of-plot to be missing
SkewTData$P[SkewTData$P > pBot] <- NA
SkewTData$P[SkewTData$P < pTop] <- NA
         # convert everything else to plot coordinates
for (name in names(SkewTData)) {
  if (name == 'P') {next}
  SkewTData[, name] <- XYplot (SkewTData[, name], SkewTData$P)$X
}
SkewTData$P <- log10(SkewTData$P)
         # define a function to use to limit variables to plot area
LimitToPlotArea <- function (name) {         # assumes x range is (0,1)
  Valid <- (SkewTData[ , name] <= 1)
  Valid[SkewTData[ , name] < 0] <- FALSE
  SkewTData[ , name][!Valid] <<- NA
}

         # mixing-ratio lines: accumulate all into xmr,ymr
xmr <- vector ()
ymr <- vector ()
for (name in names(SkewTData)) {
  if (grepl ("MR", name)) {
    #v <- sub ("MR", "", name)
    #val <- as.numeric (v)
         # set points outside plot range to missing
    Valid <- (SkewTData[,name] <= 1)
    Valid[(SkewTData[ , name] < 0)] <- FALSE
    SkewTData[, name][!Valid] <- NA
    xmr <- c(xmr, SkewTData[ , name])
    ymr <- c(ymr, SkewTData$P)
  }
}
MRDF <- data_frame (X=unlist(xmr), Y=ymr)
g <- g + geom_path (data=MRDF, aes(x=X, y=Y), color='darkgreen', lty=4, lwd=0.8, na.rm=TRUE)

         # potential temperature lines
xmth <- vector ()
ymth <- vector ()
for (name in names(SkewTData)) {
  if (grepl ("Theta", name)) {
    if (grepl ("R", name) || grepl ("B", name) || grepl ("P", name) || 
          grepl("I", name)) {next}
    Valid <- (SkewTData[ , name] <= 1)
    Valid[(SkewTData[ , name] < 0)] <- FALSE
    SkewTData[ , name][!Valid] <- NA
    xmth <- c(xmth, SkewTData[ , name])
    ymth <- c(ymth, SkewTData$P)
  }
}
MRDFTH <- data_frame (X=unlist(xmth), Y=ymth)
g <- g + geom_path (data=MRDFTH, aes(x=X, y=Y), color='darkorange', lty=1, lwd=0.4, na.rm=TRUE)

         # equivalent potential temperature: have several to choose from:
         #   I  results from integration
         #   R  results from Rossby definition
         #   B  results from Bolton definition
         #   P  results from Davies-Jones definition
ThetaESelection <- "P"
ThetaEVariable <- paste ("Theta", ThetaESelection, sep='')

## equivalent potential temperature
xmI <- vector ()
ymI <- vector ()
for (name in names(SkewTData)) {
  if (grepl (ThetaEVariable, name)) {
    #v <- sub (ThetaEVariable, "", name)
    #val <- as.numeric (v)
    Valid <- (SkewTData[ , name] <= 1)
    Valid[SkewTData[ , name] < 0] <- FALSE
    SkewTData[ , name][!Valid] <- NA
    xmI <- c(xmI, SkewTData[ , name])
    ymI <- c(ymI, SkewTData$P)
  }
}
MRDFI <- data_frame (X=unlist(xmI), Y=ymI)
g <- g + geom_path (data=MRDFI, aes(x=X, y=Y), color='red', lty=1, lwd=0.4, na.rm=TRUE)

## save the diagram for other uses
skewTDiagram <- g
save(skewTDiagram, pBot, pTop, tBot, tTop, file="./skewTDiagram.Rdata")

@

\subsection{Adding flight data to the background}

Once the diagram is constructed as above, the following code chunk
can be used to superimpose a measured sounding. Furthermore, the diagram
can be preserved before this addition so that subsequent uses can
just retrieve the ggplot definition of the background without the
need to construct it again.

This is the basis for the function in Ranadu called SkewTDiagram(
), which returns the plot definition with a supplied sounding added
to the background as preserved here.

<<add-flight-data, echo=TRUE, include=TRUE, fig.height=6, warning=FALSE>>=

## plot a sample sounding
# load("./skewTDiagram.Rdata")
# g <- skewTDiagram
Directory <- DataDirectory ()
Flight <- "rf16"   			
Project = "DEEPWAVE"			
fname = sprintf("%s%s/%s%s.nc", Directory,Project,Project,Flight)
Data <- getNetCDF (fname, standardVariables(c("THETAP")))		
r <- setRange (Data$Time, 123100, 125500)
DS <- Data[r, c("PSXC", "ATX", "DPXC")]
DP <- data_frame (P=XYplot (DS$ATX, DS$PSXC)$Y, ATX=XYplot (DS$ATX, DS$PSXC)$X, DPXC=XYplot(DS$DPXC, DS$PSXC)$X)
g <- g + geom_path (data=DP, aes(x=ATX, y=P, color='ATX'), lwd=1.5, na.rm=TRUE)
g <- g + geom_path (data=DP, aes(x=DPXC, y=P, color='DPXC'), lwd=1.5, na.rm=TRUE)
g <- g + theme(legend.position=c(0.25,0.83), legend.background=element_rect(fill="white"))
g <- g + labs(color='Measurement')
g <- g + scale_colour_manual(name = "Measurement",values = c('black', 'darkgreen'))
print(g)

@

\begin{center}
\textsf{\textcolor{blue}{-- End of Memo --}}
\par\end{center}

\vfill\eject

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & git@github.com:WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}

\attachm{\Sexpr{thisFileName}.Rnw\\\Sexpr{thisFileName}.pdf\\skewTDiagram.Rdata\\SessionInfo}
%\cc{first attachment\\second\\3rd att}
%\attach{attachment}
%\attachm{first\\second} %\cc{first attachment\\second\\3rd att}
<<save-system-info, echo=FALSE>>= 
cat (toLatex(sessionInfo()), file="SessionInfo")

@ 
<<make-zip-archive, echo=TRUE, INCLUDE=TRUE>>=
system (sprintf("zip %s.zip %s.Rnw %s.pdf skewTDiagram.Rdata SessionInfo", thisFileName, thisFileName, thisFileName))

@ 

%\cc{first attachment\\second\\3rd att}
\end{document}
